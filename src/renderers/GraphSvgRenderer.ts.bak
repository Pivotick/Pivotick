import { select as d3Select, type Selection } from 'd3-selection'
import { zoom as d3Zoom, type ZoomBehavior } from 'd3-zoom'
import { Edge } from '../Edge'
import { Node } from '../Node'
import { NodeDrawer } from './NodeDrawer'
import { EdgeDrawer } from './svg/EdgeDrawer'
import type { Graph } from '../Graph'
import type { GraphSvgRendererOptions } from '../GraphOptions'
import merge from 'lodash.merge'
import { GraphInteractions } from '../GraphInteractions'



const DEFAULT_RENDERER_OPTIONS = {
    minZoom: 0.1,
    maxZoom: 10,
    defaultNodeStyle: {
        shape: 'circle',
        color: '#007acc',
        size: 10,
        strokeColor: '#fff',
        strokeWidth: 2,
    },
    defaultEdgeStyle: {
        strokeColor: '#999',
        strokeWidth: 2,
        opacity: 0.8,
        curveStyle: 'bidirectional',
    },
} satisfies GraphSvgRendererOptions

export class GraphSvgRenderer {
    private container: HTMLElement
    private graph: Graph
    private zoom: ZoomBehavior<SVGSVGElement, unknown>
    private graphInteraction: GraphInteractions

    public nodeDrawer: NodeDrawer
    public edgeDrawer: EdgeDrawer

    private options: GraphSvgRendererOptions
    private svgCanvas: SVGSVGElement
    private progressBar: SVGRectElement

    private svg: Selection<SVGSVGElement, unknown, null, undefined>
    private zoomGroup: Selection<SVGGElement, unknown, null, undefined>
    private edgeGroup: Selection<SVGGElement, unknown, null, undefined>
    private nodeGroup: Selection<SVGGElement, unknown, null, undefined>
    private defs: Selection<SVGDefsElement, unknown, null, undefined>

    private nodeGroupSelection!: Selection<SVGGElement, Node, SVGGElement, unknown>
    private edgeGroupSelection!: Selection<SVGPathElement, Edge, SVGGElement, unknown>
    private nodeSelection!: Selection<SVGGElement, Node, SVGGElement, unknown>
    private edgeSelection!: Selection<SVGPathElement, Edge, SVGGElement, unknown>

    constructor(graph: Graph, container: HTMLElement, options: Partial<GraphSvgRendererOptions>) {
        this.graph = graph
        this.container = container

        this.options = merge({}, DEFAULT_RENDERER_OPTIONS, options)

        this.graphInteraction = new GraphInteractions(this.graph, this)
        this.nodeDrawer = new NodeDrawer(this.options, this.graph, this)
        this.edgeDrawer = new EdgeDrawer(this.options, this.graph, this)

        this.svgCanvas = document.createElementNS('http://www.w3.org/2000/svg', 'svg')
        this.svgCanvas.setAttribute('width', '100%')
        this.svgCanvas.setAttribute('height', '100%')
        this.svgCanvas.setAttribute('fill', 'none')

        this.container.appendChild(this.svgCanvas)
        this.svg = d3Select(this.svgCanvas)

        this.zoomGroup = this.svg.append('g').attr('class', 'zoom-layer')
        this.edgeGroup = this.zoomGroup.append('g').attr('class', 'edges')
        this.nodeGroup = this.zoomGroup.append('g').attr('class', 'nodes')
        this.defs = this.svg.append('defs')
        this.edgeDrawer.renderMarkers(this.defs)

        this.zoom = d3Zoom<SVGSVGElement, unknown>()
        this.svg.call(this.zoom)
        this.svg.on('dblclick.zoom', null)
        this.zoom
            .scaleExtent([this.options.minZoom, this.options.maxZoom])
            .on('zoom', (event) => {
                this.zoomGroup.attr('transform', event.transform)
            })

        const loadingPb = document.createElementNS('http://www.w3.org/2000/svg', 'g')

        // Create the track
        const track = document.createElementNS('http://www.w3.org/2000/svg', 'rect')
        track.setAttribute('width', '200')
        track.setAttribute('height', '8')
        track.setAttribute('fill', '#e0e0e0')
        track.setAttribute('rx', '4')
        track.setAttribute('ry', '4')
        loadingPb.appendChild(track)

        // Create the progress fill
        const progressFill = document.createElementNS('http://www.w3.org/2000/svg', 'rect')
        progressFill.setAttribute('id', 'progress-fill')
        progressFill.setAttribute('width', '0')
        progressFill.setAttribute('height', '8')
        progressFill.setAttribute('fill', '#3f51b5')
        progressFill.setAttribute('rx', '4')
        progressFill.setAttribute('ry', '4')
        loadingPb.appendChild(progressFill)

        // If you want to store a reference
        this.progressBar = progressFill

    }

    public init(): void {
        this.update()
        this.graphInteraction.init()
    }

    public update(): void {
        const nodes = this.graph.getNodes()
        this.nodeGroupSelection = this.nodeGroup
            .selectAll<SVGGElement, Node>('g.node-shape')

        this.nodeSelection = this.nodeGroupSelection
            .data(nodes, (node: Node) => node.id)
            .join(
                (enter) => {
                    return enter
                        .append('g').classed('node-shape', true)
                        .each((node: Node, i: number, nodes: ArrayLike<SVGGElement>) => {
                            const selection = d3Select<SVGGElement, Node>(nodes[i])
                            this.nodeDrawer.renderNode(selection, node)
                        })
                },
                (update) => {
                    return update.each((node: Node, i: number, nodes: ArrayLike<SVGGElement>) => {
                        const selection = d3Select<SVGGElement, Node>(nodes[i])
                        selection.selectChildren().remove()
                        this.nodeDrawer.renderNode(selection, node)
                    })
                },
                exit => exit.remove()
            )

        const edges = this.graph.getEdges()
        this.edgeGroupSelection = this.edgeGroup
            .selectAll<SVGPathElement, Edge>('path')

        this.edgeSelection = this.edgeGroupSelection
            .data(edges, (edge: Edge) => edge.id)
            .join(
                (enter) => enter
                    .append('path')
                    .each((edge: Edge, i: number, edges: ArrayLike<SVGPathElement>) => {
                        const selection = d3Select<SVGPathElement, Edge>(edges[i])
                        this.edgeDrawer.renderEdge(selection, edge)
                    }),
                update => update
                    .each((edge: Edge, i: number, edges: ArrayLike<SVGPathElement>) => {
                        const selection = d3Select<SVGPathElement, Edge>(edges[i])
                        selection.selectChildren().remove()
                        this.edgeDrawer.renderEdge(selection, edge)
                    }),
                exit => exit.remove()
            )
    }

    public getCanvas(): SVGSVGElement {
        return this.svgCanvas
    }

    public getCanvasSelection(): Selection<SVGSVGElement, unknown, null, undefined> {
        return this.svg
    }

    public updatePositions(): void {
        this.updateEdgePositions() // Render edges first so nodes are drawn on top of them
        this.updateNodePositions()
    }

    public updateNodePositions(): void {
        this.nodeSelection
            .attr('transform', d => `translate(${d.x ?? 0},${d.y ?? 0})`)
    }

    public getNodeSelection(): Selection<SVGGElement, Node, SVGGElement, unknown> {
        return this.nodeSelection
    }

    public getEdgeSelection(): Selection<SVGPathElement, Edge, SVGGElement, unknown> {
        return this.edgeSelection
    }

    private updateEdgePositions(): void {
        this.edgeSelection
            .attr('d', (edge: Edge): string | null => {
                return this.edgeDrawer.linkPathRouter(edge)
            })
    }

    public layoutComputationProgress(progress: number): void {
        this.progressBar.setAttribute('width', `${progress*100}%`)
    }

}
